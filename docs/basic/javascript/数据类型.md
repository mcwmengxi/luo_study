---
title: JavaScript数据类型
date: 2021 11 20
author: luo
img: 
categories: 前端
tags:
  - JavaScript
---

### 数据类型
简单数据类型 String Number Boolean Undefined Null Symbol
复杂数据类型 Object (对象)

#### typeof操作符
确定任意变量的数据类型,会返回下列字符串
"undefined" 表示值未定义；
"boolean" 表示值为布尔值；
"string" 表示值为字符串；
"number" 表示值为数值；
"object" 表示值为对象（而不是函数）或 null ； "function" 表示值为函数；
"symbol" 表示值为符号
```javascript
console.log(typeof null); //object
console.log(typeof Function); //function
console.log(typeof NaN); //number
console.log(typeof undefined);//undefined
```
#### Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined
未初始化变量的值为undefined
增加这个特殊值的目的就是为了正式明确**空对象指针(null)**和未初始化变量的区别。
undefined是一个**假值**
#### Null 类型
Null 类型同样只有一个值，即特殊值null
null 值表示一个空对象指针
定义将来要保存对象值的变量时，使用null来初始化，表示该变量一个对象的引用
null是一个**假值**
undefined 值是由 null 值派生而来的,定义它们为表面上相等
```javascript
console.log(null == undefined);//true ==比较时会转换它的操作数
console.log(null === undefined);//false
```
#### Boolean 类型
Boolean(布尔值)类型有两个字面值： true 和 false
不同类型与布尔值之间的转换规则
| 数据类型 |  转换为true 的值    |   转换为 false的值   |
| -------- | ---- | ---- |
|    String     |   非空字符串   |  "" （空字符串）    |
|    Number      |  非零数值（包括无穷值）    |  0 、 NaN （参见后面的相关内容）    |
|    Object      |   任意对象   |   null   |
|    Undefined      |  NA    |  undefined    |

#### Number 类型
Number 类型:整数和浮点值
浮点值的精确度最高可达17位小数
```javascript
//进制
let octalNum1 = 070 // 八进制的56 
let octalNum2 = 079 // 无效的八进制值，当成79处理
let octalNum3 = 08 // 无效的八进制值，当成8处理
let hexNum1 = 0xA; // 十六进制10 let hexNum2 = 0x1f; // 十六进制31

//
let floatNum1 = 1.; // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数10处理

let floatNum = 3.125e7; // 等于31250000

console.log(0.1 + 0.2);//0.30000000000000004
```

最小数值Number.MIN_VALUE, 最大数值 Number.MAX_VALUE, Infinity(无穷)值, isFinite() 函数确定一个值是不是有限大
```javascript
let number = Number.MAX_VALUE + Number.MAX_VALUE
console.log(isFinite(number)); //false
```
**NaN**
有一个特殊的数值叫 NaN ,意思是“不是数值”(Not a Number),用于表示本来要返回数值的操作失败了(而不是抛出错误)。
NaN 不等于包括 NaN 在内的任何值
任何涉及 NaN 的操作始终返回 NaN (如NaN/10)

```javascript
console.log(0 / 0); //NaN
console.log(5 / 0); //Infinity
console.log(NaN / 0); //NaN
console.log(NaN / NaN); // NaN
console.log(NaN == NaN); // false
```
**isNaN()** 函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。该函数会尝试把它转换为数值
任何不能转换为数值的值都会导致这个函数返回 true
```javascript
console.log(isNaN(NaN)); // true 
console.log(isNaN(10)); // false，10是数值
console.log(isNaN("10")); // false，可以转换为数值10 
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值1
```
**数值转换**
**Number()** 、**parseInt()**和**parseFloat()** 。Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

**Number()转换规则**
- 布尔值：true为1，false为0
- null：返回0
- undefined：返回NaN
- 字符串
  - 如果字符串包含数值且只包含与数值相关的符号(+,浮点数,进制数),将会转换为对应的数字
  - 如果是" "，返回0
  - 否则，返回NaN
```javascript
console.log(Number('+1223'), Number('070'), Number('1.1'), Number('0xf')); //1223 70 1.1 15
console.log(Number(""));//0
console.log(Number('123tg')); //NaN
```
  - 对象:调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN,则调用toString()方法，再按照转换字符串的规则转换。

**parseInt()转换规则**
它从第一个非空字符开始检测，如果第一个不是数值，加减号，直接返回NaN，否则会依次检测数值，直到非数值出现停止
如果只是一个空字符串，返回NaN
第二个参数用于区分进制数转换
```javascript
console.log(parseInt('  112'), parseInt('+ 112'), parseInt('+112'), parseInt(' ')); //112 NaN 112 NaN
console.log(parseInt('112fg'));//112
console.log(parseInt('070'), parseInt('0xf',16));//70 15
```
#### String类型
- 几乎所有值都有toString()方法，null 和 undefined 值没有toString() 方法
- String() 转型函数
  - 如果值有 toString() 方法，则调用该方法（不传参数）并返回结果。
  - 如果值是 null ，返回 "null" 。
  - 如果值是 undefined ，返回 "undefined" 。
```console.log(String(null), String(undefined), String("111"));//"null" "undefined" "111"```
- 插值表达式 ``` `${}` ```
#### Symbol 类型
- Symbol 用来创建唯一标识符的基本数据类型
- 即使描述一样的Symbol值也是不同的,它的实例对象的description属性是一样的
```javascript
// id1是描述为 "id" 的 Symbol
let id1 = Symbol("id");
let id2 = Symbol("id");

console.log(id1 == id2); // false
console.log(id1.description == id2.description); //true
```
- Symbol 允许我们创建对象的“隐藏”属性,Symbol的唯一标识决定了给对象创建了Symbol类型的属性只有自身才能操作
- 对象字面量中的使用Symbol,需要使用方括号把它括起来
- Symbol 属性不参与 for..in 循环,也不参与`Object.keys()`。
- 对于对象克隆、合并,需要它们的所有属性(包括Symbol属性) 
```javascript
let id = Symbol('id')
let user ={
    name:"nangong",
    age:25,
    [id]:1, // symbol类型的id
    id:24 // 字符串 “id”
}
for (let key in user) {
    console.log(user[key]);//nangong 25 24
}
console.log(Object.keys(user));// [ 'name', 'age', 'id' ]
// 当我们克隆或者合并一个object 时，通常希望所有属性被复制(包括像 id 这样的 Symbol)。
console.log(Object.assign({},user)); // { name: 'nangong', age: 25, id: 24, [Symbol(id)]: 1 }
```

**全局 symbol**
- 通过全局Symbol注册表实现访问相同名字的Symbol返回相同的Symbol
- 从注册表中读取（不存在则创建）Symbol，使用 Symbol.for(key)。
- Symbol.keyFor 内部使用全局 Symbol 注册表来查找Symbol的键,它不适用于非全局 Symbol
```javascript
let id = Symbol.for('id') // 如果该Symbol不存在，则创建它
let newId = Symbol.for('id') 
let globalSymbol = Symbol.for("id");
let localSymbol = Symbol("id");

console.log(id===newId);// true 通过Symbol.for('name')返回的值都是相同的symbol
console.log(Symbol.keyFor(id));// id 通过Symbol.keyFor(id)获取它的名字

```
**系统 Symbol**
- Symbol.toPrimitive 允许我们将对象描述为原始值转换。
- 使用 Symbol.iterator来进行迭代操作
- Symbol.hasInstance
- Symbol.isConcatSpreadable


**Symbol使用场景**：
1. “隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的symbol。因此，该属性将受到保护，防止被意外使用或重写。因此我们可以使用Symbol属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。
2. JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内置行为。例如，在本教程的后面部分，我们将使用 Symbol.iterator 来进行 迭代 操作，使用 Symbol.toPrimitive 来设置 对象原始值的转换 等等。
ps.有一个内置方法 Object.getOwnPropertySymbols(obj)允许我们获取所有的 Symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的所有键，包括 Symbol



