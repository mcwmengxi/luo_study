---
title: 类
---

# 类

## 类的基本语法

- 在 JavaScript 中，类是一种函数。

**类与构造器的不同之处**
- 通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true。
- 类方法不可枚举。类定义将 "prototype" 中的所有方法的 enumerable 标志设置为 false。
- 类总是使用 use strict。 在类构造中的所有代码都将自动进入严格模式。

**类表达式**
- 就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。
- 类似于命名函数表达式（Named Function Expressions），类表达式可能也应该有一个名字，该名字仅在类内部可见。
```javascript
// “命名类表达式（Named Class Expression）”
// (规范中没有这样的术语，但是它和命名函数表达式类似)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass 这个名字仅在类内部可见
  }
};

new User().sayHi(); // 正常运行，显示 MyClass 中定义的内容

alert(MyClass); // error，MyClass 在外部不可见
```
**类字段**
类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在 User.prototype：
```javascript
class User {
  name = "John";

  sayHi() {
    alert(`Hello, ${this.name}!`);
  }
}

new User().sayHi(); // Hello, John!
```
**解决this丢失问题**
- 传递一个包装函数，例如 setTimeout(() => button.click(), 1000)。
- 将方法绑定到对象，例如在 constructor 中。
- 类字段提供了另一种非常优雅的语法click = () => {...}。是基于每一个对象被创建的，在这里对于每一个 Button 对象都有一个独立的方法，在内部都有一个指向此对象的 this。我们可以把 button.click 传递到任何地方，而且 this 的值总是正确的。

MyClass 是一个函数（我们提供作为 constructor 的那个），而 methods、getters 和 settors 都被写入了 MyClass.prototype。
```javascript
class User{
    // 来字段
    age=23 
    constructor(name){
        this.name = name
        this.printName = () => {
            console.log(this.name);
        } 
    }
    //  Getters/setters
    get name(){
        // return this.b
        return this._name
    }
    set name(value){
        if (value.length < 4) {
            console.log("Name is too short.");
            return;
        }
        // this.b = value
        this._name = value
    }
    // 计算属性名称 […],此处用的是symbol
    [Symbol.iterator](){// 有计算名称（computed name）的方法

    }
    showName(){
        console.log(this.name);
    } 
    printAge(){
        console.log(this.age);
    }
}

```

## 类继承

**类继承**
- 扩展一个类(也就是继承)：class Child extends Parent,这意味着 Child.prototype.__proto__ 将是 Parent.prototype，所以方法会被继承。
```javascript
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit("White Rabbit");

rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!

```
Class Rabbit 的对象可以访问例如 rabbit.hide() 等 Rabbit 的方法，还可以访问例如 rabbit.run() 等 Animal 的方法。

在内部，关键字 extends 使用了很好的旧的原型机制进行工作。它将 Rabbit.prototype.[[Prototype]] 设置为 Animal.prototype。所以，如果在 Rabbit.prototype 中找不到一个方法，JavaScript 就会从 Animal.prototype 中获取该方法。

![image-name](https://zh.javascript.info/article/class-inheritance/animal-rabbit-extends.svg)
- JavaScript内建对象同样也使用原型继承。例如，Date.prototype.[[Prototype]] 是 Object.prototype。所以日期可以访问通用对象的方法。

**重写方法**

- 由于原型链的查找机制，继承类找到对应方法就不会调用父类的方法了
- 如果想要父类的方法基础上扩展，可以执行super.method(...)来调用一个父类方法。
- 箭头函数没有 super，如果被访问，它会从外部函数获取，和this类似。
```javascript
class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // 1 秒后调用父类的 stop
  }
}
```

**重写 constructor**
* 继承类的 constructor 必须调用 super(...)，并且 (!) 一定要在使用 this 之前调用。
  - js中,继承类(派生构造器derived)的构造函数与其他函数有区别,它具有特殊的内部属性[[constructorkind]]:"dervied".
  - 同时这个属性会影响new关键字的行为
    - 当new执行的是一个常规函数时,创建一个空对象，并赋值给this.
    - 如果是继承的constructor执行时,它不会执行上述操作,而是想要父类的constructor来完成
    - 所以派生的constructor需要调用super来执行父类的constructor,否则this对象不会被创建,并且它需要在使用this之前调用 super()

**重写类字段**
- 父类构造器总是会使用它自己字段的值，而不是被重写的那一个。
  - 对于基类(还未继承任何东西的那种)，在构造函数调用前初始化。
  - 对于派生类，在super()后立刻初始化。
  - 由于new MyWorld()派生类中没有自己的构造器,会调用super执行KeJiWorld父类构造器,此时派生类的类字段还未初始化,所以会使用父类的类字段。
```javascript
class KeJiWorld {
    worldName = "KeJiWorld"
    constructor(name){
        this.name = name
        console.log(this.worldName);
    }
    start_shadow(){
        console.log("开启光影",this.worldName);
    }
}
class MyWorld extends KeJiWorld{
    worldName = "MyWorld"
    // 重写构造函数
    constructor(name,shadowName){
        super(name)
        this.shadowName = shadowName
    }

    // 重写方法
    start_shadow(){
        super.start_shadow()
        console.log("添加自定义光影:"+this.shadowName);
    }
    add_model(){
        console.log("添加新模组");
    }

}
new KeJiWorld("")
let myWorld = new MyWorld("","cierrl_shadow")

myWorld.start_shadow()
myWorld.add_model()

```
**继承和super`[[HomeObject]]`背后的内部机制**
**[[HomeObject]]**
当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为了该对象。然后super使用它来解析（resolve）父原型及其方法。
方法在内部的 [[HomeObject]] 属性中记住了它们的类/对象。这就是super如何解析父方法的。

```javascript
let animal = {
  name: "Animal",
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "Rabbit",
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "Long Ear",
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// 正确执行
longEar.eat();  // Long Ear eats.
```
- 将一个带有super的方法从一个对象复制到另一个对象是不安全的。
```javascript
let animal = {
  sayHi() {
    alert(`I'm an animal`);
  }
};

// rabbit 继承自 animal
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    alert("I'm a plant");
  }
};

// tree 继承自 plant
let tree = {
  __proto__: plant,
  sayHi: rabbit.sayHi // (*)
};

tree.sayHi();  // I'm an animal (?!?)
```
![image-name](https://zh.javascript.info/article/class-inheritance/super-homeobject-wrong.svg)

- [[HomeObject]] 是为类和普通对象中的方法定义的
```javascript
let animal = {
    // [[HomeObject]] 是为类和普通对象中的方法定义的
  eat: function() { // 这里是故意这样写的，而不是方法 eat() {... 所以没有 [[HomeObject]] 属性
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // 错误调用 super（因为这里没有 [[HomeObject]]）

```

## 静态属性和静态方法

**静态属性和方法**
- 通过static关键字标记，标记后的的属性和方法作为类自身的方法和属性,而不是赋给它的 "prototype"
- 静态方法被用于实现属于整个类的功能。它与具体的类实例无关。
- 静态方法用于实现属于该类但不属于该类任何特定对象(prototype)的函数。
**继承静态属性和方法**
- 静态属性和方法是可被继承的。
- Rabbit extends Animal 创建了两个 [[Prototype]] 引用：
```javascript
class Animal {}
class Rabbit extends Animal {}

// 对于静态的
alert(Rabbit.__proto__ === Animal); // true

// 对于常规方法
alert(Rabbit.prototype.__proto__ === Animal.prototype); // true
```

  - Rabbit 函数原型继承自 Animal 函数。在构造函数之间会设置原型（为了获取静态方法）。
  - Rabbit.prototype 原型继承自 Animal.prototype。在构造函数的 "prototype" 之间设置原型（为了获取实例方法）。
![image-name](https://zh.javascript.info/article/static-properties-methods/animal-rabbit-static.svg)

- Function.prototype 有一些“通用”函数方法，例如 call 和 bind 等。在上述的两种情况下它们都是可用的，因为对于内建的 Object 构造函数而言，`Object.__proto__ === Function.prototype`。
- 所有的对象通常都继承自 Object.prototype,类也是对象的一种，所以也会继承Object.prototype的方法,但是不能使用Object的静态方法，像`getOwnPropertyNames`.但是通过extends关键字却可以实现

```javascript
class Rabbit{}
Rabbit.__proto__ === Function.prototype
Rabbit.prototype.__proto__ === Object.prototype

class Rabbit extends Object
Rabbit.__proto__ === Object
Rabbit.prototype.__proto__ === Object.prototype
```

![image-name](https://zh.javascript.info/task/class-extend-object/rabbit-extends-object.svg)

## 私有的和受保护的属性和方法

- 丛面向对象编程oop的角度来说,进行内部接口与外部接口的划分可以称做封装。
- 就使用者的角度来说,可以提供相应的服务,但是无法更改一些重要的地方
- 为了隐藏内部接口,提供了受保护和私有的属性
  - 私有字段以#开头。JavaScript确保我们只能从类的内部访问它们,限制较大。
  - 受保护的字段以_开头。这是一个默认约定。程序员应该只通过它的类和从它继承的类中访问以 _ 开头的字段。

## 扩展内建类

**扩展内建类**
- 内建的类，例如 Array，Map 等也都是可以扩展的（extendable）。
- `static get [Symbol.species](){}`控制着map或 filter这样的内建方法返回常规数组还是增强的数组，通过在Symbol.species中返回创建新实体的constructor.
```javascript
class PowerArray extends Array{

    isEmpty(){
        return this.length===0
    }
    static get [Symbol.species](){
        // 内建方法将使用这个Array作为constructor,filter、map等内建方法创建的新结果数组就不具有增强数组的特性
        // return Array
        return PowerArray
    }
}

let arr  = new PowerArray(1, 2, 5, 10, 50)
const newArr = arr.filter(item => item===10)
console.log(arr.isEmpty());// false
console.log(newArr.isEmpty());// false

```
 
**内建类没有静态方法继承**
- 当一个类扩展另一个类时，静态方法和非静态方法都会被继承。
- 内建类却是一个例外。它们相互间不继承静态方法。
- Array 和 Date 都继承自 Object，所以它们的实例都有来自 Object.prototype 的方法。但 Array.[[Prototype]] 并不指向 Object，所以它们没有例如 Array.keys()（或 Date.keys()）这些静态方法。

![image-name](https://zh.javascript.info/article/extend-natives/object-date-inheritance.svg)


## 类检查 instanceof

### 类型检查

- typeof,适用于原始数据类型,返回string.
- instanceof,适用于所有对象,返回true/false
- `{}.toString.call`原始数据类型，内建对象，包含**Symbol.toStringTag属性**的对象,返回string.

**instanceof**

instanceof 用于检查一个对象是否属于某个特定的 class。
- instanceof 在检查中会将原型链考虑在内，手动中断原型链，查找也会在中断地方断掉。
- 在静态方法Symbol.hasInstance中设置自定义逻辑,instanceof会优先执行这个方法，再去判断原型链。
- obj instanceof Class 算法执行顺序
  1. 如果这儿有静态方法 Symbol.hasInstance，那就直接调用这个方法：
```javascript
// 设置 instanceOf 检查
// 并假设具有 canEat 属性的都是 animal
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

let obj = { canEat: true };

alert(obj instanceof Animal); // true：Animal[Symbol.hasInstance](obj) 被调用

```
  2. 大多数class没有Symbol.hasInstance。所以一般的逻辑是：使用 obj instanceOf Class 检查 Class.prototype 是否等于 obj 的原型链中的原型之一。

```javascript
obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
// 如果任意一个的答案为 true，则返回 true
// 否则，如果我们已经检查到了原型链的尾端，则返回 false
```

![image-name]((https://zh.javascript.info/article/instanceof/instanceof.svg)

**Object.prototype.toString方法来检查类型**

- 一个普通对象被转化为字符串时为返回[object Object]，这是通过toString方法实现的。
- 可以通过某些方式增强这个toString方法，作为 typeof 的增强版或者 instanceof 的替代方法来使用。
- 如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof。
- 内建的toString方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。
  - 对于 number 类型，结果是 [object Number]
  - 对于 boolean 类型，结果是 [object Boolean]
  - 对于 null：[object Null]
  - 对于 undefined：[object Undefined]
  - 对于数组：[object Array]
  - Symbol.toStringTag可自定义toString方法

```javascript
let objectToString = Object.prototype.toString
// 对普通对象没有增强
// let obj = {name:"nangong"} 

// 对内建对象、原始类型增强
let arr = [1,3,undefined,'f']
console.log(arr.toString());// 1,3,,f
console.log(objectToString.call(arr));//[object Array]

let xh = null
let num = 12
console.log(objectToString.call(xh));// [object Null]
console.log(objectToString.call(num));// [object Number]
// 可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的toString方法的行为。
let obj = {
    name:"nangong",
    [Symbol.toStringTag]:"User"
}
console.log({}.toString.call(obj));// [object User]
//  node全局对象
console.log(global[Symbol.toStringTag]);//global
console.log({}.toString.call(global));// [object global]
```

## Mixin

- Mixin — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。
- 一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。
- 使用mixin作为一种通过添加多种行为(事件订阅-触发模式)来扩充类的方法。
- mixin需要与对象原型合并，所以需要注意mixin里面方法的命名冲突

构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象，Mixin可以在自己内部使用继承。通过对象合并的方式来实现继承其他类的效果`Object.assign(User.prototype, sayHiMixin);`,下面是一个mixin被继承的例子
```javascript
let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (或者，我们可以在这儿使用 Object.create 来设置原型)

  sayHi() {
    // 调用父类方法
    super.say(`Hello ${this.name}`); // (*)
  },
  sayBye() {
    super.say(`Bye ${this.name}`); // (*)
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// 拷贝方法
Object.assign(User.prototype, sayHiMixin);

// 现在 User 可以打招呼了
new User("Dude").sayHi(); // Hello Dude!
```
在sayHiMixin内部对父类方法 super.say()的调用会在mixin的原型中查找方法，而不是在class中查找。

![image-name](https://zh.javascript.info/article/mixins/mixin-inheritance.svg)

