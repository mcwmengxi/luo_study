---
title: 对象
---

## 对象

### 普通对象
**计算属性**
当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做计算属性。
[fruit] 含义是属性名应该从fruit变量中获取。
```javascript
let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // 属性名是从 fruit 变量中得到的
};

alert( bag.apple ); // 5 如果 fruit="apple"
```
**属性存储和访问及其它**
- 存储属性采用键值对形式，其中：属性的键必须是字符串或者symbol(通常是字符串),值可以是任何类型。
- 访问属性
  - 点符号: obj.property。当属性名是已知且简单的时候
  - 方括号 obj["property"]，方括号允许从变量中获取键，例如 obj[varWithKey]。
- 其他操作：
  - 删除属性：delete obj.prop。
  - 检查是否存在给定键的属性："key" in obj。
  - 遍历对象：for(let key in obj) 循环。
- 用const声明的对象能被修改。const 声明仅固定user的值，而不是该对象里面的内容。当我们尝试将user=...作为一个整体进行赋值时,const才会抛出错误。

### 对象引用和复制
- 对象通过引用被赋值和拷贝。被赋值了对象类型的变量存储的不是对象本身，而是该对象在内存中的地址(该对象的引用)
- 当对象变量被复制时，只是引用被复制，两者指向的还是同一个内存地址(同一个对象)
```javascript
let user = { name: 'John' };
let admin = user;

admin.name = 'Pete'; // 通过 "admin" 引用来修改
alert(user.name); // 'Pete'，修改能通过 "user" 引用看到
```
![image-name](https://zh.javascript.info/article/object-copy/variable-copy-reference.svg)

- 为了创建“真正的拷贝”(一个克隆)，我们可以使用 Object.assign 来做所谓的“浅拷贝”（嵌套对象通过引用进行拷贝）
```javascript
// 浅拷贝
let user = {
    name: "nangong",
    sizes: {
      height: 182,
      width: 50
    }
};
let newUser = Object.assign({},user)

console.log(newUser==user);//false
console.log(newUser.sizes===user.sizes);// true 嵌套对象通过引用被复制,实际还是共用一个地址

// 类似与_.clone(objects);
var objects = [{ 'a': 1 }, { 'b': 2 }];
let newObj = Object.assign([],objects)
console.log(newObj===objects);// false
console.log(newObj[0]===objects[0]);// true
```
- 为了创建“真正的拷贝”(一个克隆),也可以使用“深拷贝”函数，例如 _.cloneDeep(obj)。
```javascript
// lodash库深克隆函数
var objects = [{ 'a': 1 }, { 'b': 2 }];
 
var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);// => false

// 以menus为依据通过递归实现的深克隆函数,有些其他情况没有完善
function cloneDeep(obj){
    let clone
    clone = {}
    if(obj instanceof Array){
        clone =[]
    }
    for(let key in obj){
        if(typeof obj[key] === "object"){
            if(obj[key] instanceof Array){
                clone[key] = []
                obj[key].forEach((item,index) => {
                    if(typeof item === "object"){
                        clone[key][index] = cloneDeep(item)
                    }else{
                        clone[key][index] =item
                    }
                })
                
            }else{
                clone[key] = cloneDeep(obj[key])
            }
            
        }else{
            clone[key] = obj[key]
        }
    }
    return clone
}
var objects = [{ 'a': 1 }, { 'b': 2 }];
var objectArr = {
    a:[{ 'a': 1 }, { 'b': 2 }],
    b:[{ 'a': 1 }, { 'b': 2 }]
}
let user = {
    name: "nangong",
    sizes: {
      height: 182,
      width: 50
    }
};
const menus ={
    a:[
    {
      text: '用户管理',
      icon: 'el-icon-setting',
      routerName: '',
      submenus: [
        {
          text: '服务信息',
          routerName: 'ServiceList'
        },
        {
          text: '新增功能',
          routerName: 'ServiceEdit'
        }
      ]
    },
    {
      text: '产品管理',
      icon: 'el-icon-menu',
      submenus: [{ text: '产品信息', routerName: 'Product' }]
    },
    {
      text: '日志信息',
      icon: 'el-icon-message',
      routerName: ''
    },
    {
      text: '自定义图片上传',
      icon: 'el-icon-upload',
      routerName: ''
    },
    3
  ],
  b:{
      "b-a":1
  },
  c:0
}
let empty =[{}]
let deep = cloneDeep(menus)
console.log(deep);
// console.log(deep[0]===objects[0]);
// console.log(deep.a[0]===objectArr.a[0]);
// console.log(deep.sizes===user.sizes);
console.log(deep.a[1]===menus.a[1]);
```


### 垃圾回收
**垃圾回收基本算法**
`mark-and-sweep`定期执行以下“垃圾回收”步骤：
  * 垃圾收集器找到所有的根，并“标记”（记住）它们。
  * 然后它遍历并“标记”来自它们的所有引用。
  * 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
  * ……如此操作，直到所有可达的（从根部）引用都被访问到。
  * 没有被标记的对象都会被删除。
![image-name](https://zh.javascript.info/article/garbage-collection/garbage-collection-5.svg)
**总结**
- 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
- 当对象是可达状态时，它一定是存在于内存中的。对象不可达时，会被垃圾回收机制回收
- 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。垃圾回收是以可达性为依据的

### 对象方法,this
**对象方法简写**
```javascript
// 这些对象作用一样,但在对象继承方面有一些细微的差别

user = {
  sayHi: function() {
    alert("Hello");
  }
};

user = {
  sayHi() { // 与 "sayHi: function()" 一样
    alert("Hello");
  }
};
```

**this**
this的值是在程序运行时得到的。

- 一个函数在声明时，可能就使用了 this，但是这个this只有在函数被调用时才会有值。
- 可以在对象之间复制函数，使对象复制后方法调用(使用对象属性)不会出错
- 以“方法”的语法调用函数时：object.method()，调用过程中的 this 值是 object。
- 请注意箭头函数有些特别：它们没有 this。在箭头函数内部访问到的 this 都是从外部获取的。

### 构造器和操作符 "new"
- 构造函数，或简称构造器，就是常规函数，构造器约定其命名首字母大写，只能使用 new 来调用。
- 函数被new操作符执行时，创建一个空对象并给了this，函数体执行为this，添加新的属性，接着返回this的值。
```javascript
// new操作符执行流程与此类似
function User(name) {
  // this = {};（隐式创建）

  // 添加属性到 this
  this.name = name;
  this.isAdmin = false;

  // return this;（隐式返回）
}
```
- 函数内部通过new.target属性,确定是构造器执行(new.target属性为函数)还是常规调用(new.target属性为undefined),
- js内置对象通过new.target属性可以实现构造器执行的时候省略new关键字
```javascript
// 实现构造器省略new关键字
function User(name,age){
    if(!new.target){
        return new User(name,age)
    }
    this.name = name;
    this.age = age
    cache = true
}

let user = User('南宫',25)
console.log(user);
```
- 构造器一般没有return。如果有的话并且是个对象类型的话将会覆盖this。返回原始类型无影响。
```javascript
function BigUser() {

  this.name = "John";

  return { newname: "Godzilla" };  // <-- 返回这个对象
}

console.log( new BigUser().newname );  // Godzilla，得到了那个对象
console.log( new BigUser().name );  // undefined
```

### 可选链 "?."
可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。不会出错的同时也给我们在编程上面造成一定困扰。仅在当左边部分不存在也没问题的情况下使用为宜。
- 可选链 ?. 不是一个运算符，而是一个特殊的语法结构
  - obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。
  - obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。
  - obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。
```javascript
// 如果 document.querySelector('.elem') 的结果为 null，则这里不存在这个元素
let html = document.querySelector('.elem').innerHTML; // 如果 document.querySelector('.elem') 的结果为 null，则会出现错误

// 可选链 ?. 解决错误
let html = document.querySelector('.elem')?.innerHTML;
console.log(html)// undefined

```

### Iterable object（可迭代对象）
- `for (let key of obj)`  中的obj对象都是可迭代的。
- 可迭代对象必须实现 Symbol.iterator 方法。
- `obj[Symbol.iterator]()`的结果被称为 迭代器（iterator）。由它处理进一步的迭代过程。
- 一个迭代器必须有next()方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。
- Symbol.iterator方法会被 for..of 自动调用，但我们也可以直接调用它。
- 内置的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。
- 字符串迭代器能够识别代理对surrogate pair(UTF-16 扩展字符 😂𩷶)。
```javascript
/**
 * 使range 对象可迭代
*/
let range = {
    from:2,
    to:5
}

// 1. for..of 调用首先会调用这个：
range[Symbol.iterator] = function (){
    // ……它返回迭代器对象（iterator object）：
    // 2. 接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值
    return {
        current:this.from,
        last:this.to,
        // 3. next() 在 for..of 的每一轮循环迭代中被调用
        next(){
            // 4. 它将会返回 {done:.., value :...} 格式的对象
            if(this.current<=this.last){
                return {done:false,value:this.current++}
            }else{
                return {done:true}
            }
        }
    }
}
for(let num of range){
    console.log(num);
}


/** 
 * range自身作为迭代器
*/
let range = {
    from:1,
    to:5,

    [Symbol.iterator](){
        this.current = this.from
        return this
    },
    next(){
        if(this.current<=this.to){
            return {done:false,value:this.current++}
        }else{
            return {done:true}
        }
    }
}

let iterator = range[Symbol.iterator]()
while(true){
    const res = iterator.next()
    if(res.done){
        break
    }
    console.log(res.value);
}
// for(let num of range){
//     console.log(num);
// }

/** 
 * 显式调用迭代器
*/
let str = "nangong"
// 实现for..of 相同的效果
let iterator = str[Symbol.iterator]()
// console.log(iterator);
while(true){
    const res = iterator.next()
    if(res.done){
        break
    }
    console.log(res.value);
}

```
**可迭代iterable和类数组array-like**
- 可迭代是指实现了Symbol.iterator方法的对象
- 类数组是指具有索引和length属性的对象
- `Array.from(obj[, mapFn, thisArg])` 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。
```javascript
/**
* 
*/
// 可迭代（iterable）
let a = 115
// 如果a不是一个可迭代对象a[Symbol.iterator]()调用会报错
a[Symbol.iterator]() // a[Symbol.iterator] is not a function

let  iterable = " rre" 
iterable[Symbol.iterator]() //会返回Object [String Iterator] {}

// 类数组（array-like）

let arrayLike={
    0:"nangong",
    1:"kyo",
    length:2
}
//  Array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。
let arr = Array.from(arrayLike)
console.log(arr);// [ 'nangong', 'kyo' ]
let  iterable = " rre" 
let charArr = Array.from(iterable)
console.log(charArr);// [ ' ', 'r', 'r', 'e' ]


/** 
 * 实现能够处理 UTF-16 扩展字符的 slice 方法
 * v8下运行结果
 */
 let str = '𝒳😂𩷶';
 console.log( str.slice(1, 3) ); // 😂𩷶
 function slice(str,start,end){
     return Array.from(str).slice(start,end).join("")
 }
 console.log(slice(str,1,3));

```

### 对象转换

当一个对象被用在需要原始值的上下文中，对象会被自动转换相应的类型
这里有三种类型（hint）,常常将number和default归为一类：
- "string"（对于 alert 和其他需要字符串的操作）
- "number"（对于数学运算）
- "default"（少数运算符）

转换算法是：
- 调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，
- 否则，如果 hint 是 "string"
  - 尝试 obj.toString()-> obj.valueOf()。
  - 否则，如果 hint 是 "number" 或者 "default"
  - 尝试 obj.valueOf() -> obj.toString()。
```javascript
let user = {
    name:"nangong",
    age:25,
    money:1000,

    // [Symbol.toPrimitive](hint){
    //     return hint == 'string' ? this.name :this.age+this.money
    // },
    // 对于 hint="string"
    toString() {
        return `{name: "${this.name}"}`;
    },

    // 对于 hint="number" 或 "default"
    valueOf() {
        return this.money;
    }
}
alert(user);
alert(+user);
alert(user+500);

// 如果没有 Symbol.toPrimitive 和 valueOf，toString 将处理所有原始转换。
let user1 = {
    name: "kyo",

    toString() {
      return this.name;
    }
  };

alert(user1); // toString -> kyo
alert(user1 + 500); // toString -> kyo500
```