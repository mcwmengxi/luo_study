---
title: 函数进阶
---

## 函数

### 函数声明
作为参数传递给函数的值，会被复制到函数的局部变量。
函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。
函数可以返回值。如果没有返回值，则其返回的结果是 undefined。
**内置函数**
内置函数：alert(message)、prompt(message, default)和confirm(question)。
**code**
```javascript
//function关键字 函数名 (参数) {函数体}
function showMessage() {
  alert( 'Hello everyone!' );
}
```

**变量**
局部变量:在函数中声明的变量只在该函数内部可见
外部变量:函数也可以访问外部变量,在没有局部变量的情况下才会使用外部变量
函数内部声明了同名变量，那么函数会遮蔽外部变量
```javascript
let userName = 'John';
function showMessage() {
  let userName = "Bob"; // 声明一个局部变量

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// 函数会创建并使用它自己的 userName
showMessage();

alert( userName ); // John，未被更改，函数没有访问外部变量。
```
**参数**

函数参数可以在函数内部修改，但是它修改的的是复制的变量，不会影响函数外部的值
```javascript
function showMessage(from, text) {

  from = '*' + from + '*'; // 让 "from" 看起来更优雅
  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// "from" 值相同，函数修改了一个局部的副本。
alert( from ); // Ann
```
函数执行如果没有提供参数，那么它会默认提供一个undefined值,可以在函数声明时在参数列表上指定初始值，也可以在函数体设置默认值等到函数执行的时候设置。
```javascript
function showMessage(from,to = 'totext', text,count) {
  //函数体设置默认值
  text = text || 'text message'
  from = '*' + from + '*'; 
  // to 参数列表上指定初始值
  // 空值合并运算符 ??
  alert( from + '-'+to+'-' + text +'-' + (count ?? "count message"));
}

showMessage("Ann");//*Ann*-totext-text message-count message
```
**返回值**

- 空值的 return 或没有 return 的函数返回值为 undefined
- 不要在 return 与返回值之间添加新行
```javascript
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
**函数命名**
    "get…" —— 返回一个值，
    "calc…" —— 计算某些内容，
    "create…" —— 创建某些内容，
    "check…" —— 检查某些内容并返回 boolean 值，等。
    jQuery 框架用 $ 定义一个函数。LoDash 库的核心函数用 _ 命名。

**总结**

### 函数表达式
- 使用表达式创建函数，但是函数在表达式之前不可见。而函数声明在其被声明的代码块内的任何位置都是可见的。
- 函数表达式在执行流程到达时创建
- 在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。所以，仅当函数声明不适合对应的任务时，才应使用函数表达式
- 严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。但是函数表达式可以通过在代码块外提前声明变量实现代码块外访问
```javascript
sayHi("John"); // Hello, John
// 函数声明
function sayHi(name) {
  alert( `Hello, ${name}` );
}

sayHi("John"); // error!
// 函数表达式
let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

### 回调函数
- 由于函数是一种特殊的值这一特性，可以把它作为参数列表的值传递，这种情况所使用的函数就是回调。
- 函数直接在参数列表中声明，且不使用函数名，就叫做匿名函数

```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
```

### 递归和堆栈
- 当一个函数解决一个任务时，在解决的过程中它可能调用自身函数。就是所谓的递归。
- 最大的嵌套调用次数（包括首次）被称为 递归深度
- 当一个函数进行嵌套调用时，递归深度等于堆栈中上下文的最大数量，将发生以下的事儿：
  - 当前函数被暂停；
  - 与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；
  - 执行嵌套调用；
  - 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。
- 链表元素 是一个使用以下元素通过递归定义的对象：
  - value。
  - next 属性引用下一个 链表元素 或者代表末尾的 null。
- 递归遍历
```javascript
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};

function calcTotal(department){
    if(Array.isArray(department)){
        return department.reduce((prev,curr)=>{
            return prev + curr.salary
        },0) 
    }else{
        let total = 0;
        for(let keys of Object.values(department)){
            total += calcTotal(keys)
        }
        return total
    }
}
console.log(calcTotal(company));//7700 
  
```

### Rest 参数与 Spread 语法
- 在列表和参数数组之间来回转换。
- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。
- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。
- 转化为数组时，Array.from()更通用
  - Array.from 适用于类数组对象也适用于可迭代对象。
  - Spread 语法只适用于可迭代对象。
- “旧式”的 arguments(类数组且可迭代的对象)也依然能够帮助我们获取函数调用中的所有参数,但无法直接使用数组方法。

### 作用域和闭包
**作用域链**
作用域链使得我们在函数内部可以直接读取外部以及全局变量。
**上下文**
上下文定义了一个函数正在执行时的作用域环境。
**作用域链**
每个JavaScript执行环境都有一个和它关联在一起的作用域链。这个作用域链是一个对象列表或对象链。

**搜寻标识符**
代码执行过程中标识符的解析是沿着作用域链逐级搜索标识符完成的，从作用域的最前端开始，依次向后搜索标识符，如果找到就停止，找不到就报错
当函数执行结束之后，执行上下文将被销毁。也就会销毁作用域链，激活对象也同样被销毁。
**闭包**(closure)
闭包是函数和函数声明时的环境的结合，环境由创建时作用域中使用到的局部变量组成，是一个特殊的对象
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数,即使在其外部函数被返回（寿命终结）了之后。
**闭包的出现**
闭包使得我们可以从外部读取局部变量
在Javascript中，只有函数内部的子函数才能读取局部变量。像下面的例子：
```javascript
function fun() {
    var name = 1
}
fun()
console.log(name === "");//true
```
在全局环境下无法访问函数B内的变量，这是因为全局函数的作用域链里，不含有函数B内的作用域。
```javascript
function fun() {
    var name = "nangong"

    return function a() {
        console.log(name);
    }

}
const A = fun()
A()//A变成一个闭包
```
**闭包的用途**
- 用于读取其他函数内部变量的函数
- 让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制gc回收

### 变量定义与顶层对象

#### var关键字

  - 不初始化的情况下，变量会自动保存一个特殊值undefined
```javascript
    var msg
    console.log(msg); //undefined
```

  - var 声明作用域

给未声明的变量赋值,创建一个全局变量,在严格模式下,抛出 ReferenceError
```javascript
    function test() {
        // 'use strict'
        message = "hi"; // 全局变量
    }
    test();
    console.log(message); // hi
```
  		局部作用域：该变量将在函数退出时被销毁
```javascript
    function test() {
        var message = "hi"; // 局部变量
    }
    test();
    console.log(message); // hi
```
  - var 声明提升

函数内使用var定义的变量都会自动提升到函数作用域顶部

```javascript
function foo() {
    console.log(name);
    var name = "nangong"
}
foo() //undefined
```
#### let

let 声明的范围是块作用域，而 var 声明的范围是函数作用域。
```javascript
  if (true) {
      var name = 'nangong'
      let age = 23
  }
  console.log(name);//nangong
  console.log(age); // ReferenceError: age is not defined

```

let**同一个块**作用域中出现冗余声明，抛出SyntaxError
```javascript
var name;
var name;
```
```javascript
var name;
let name;// SyntaxError
```

**暂时性死区**
  let 声明的变量不会在作用域中被提升
  从当前作用域顶层到变量声明之间引用变量会抛出ReferenceError，这段区域也叫作暂时性死区
```javascript
let x = 1;

function func() {
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 2;
}

func();
```
**全局声明**
let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会),let 声明仍然是在全局作用域中发生。
```javascript
//v8环境下运行
var name = 'nangong'
let age = 23

console.log(window.name);//nangong
console.log(window.age);//undefined

```
**条件式声明**
不能使用 let 进行条件式声明
```javascript
console.log(typeof name); //undefined
let name // 使用let 定义过的变量typeof可能会抛出错误，暂时性死区导致
```
**for循环中的let声明**
每次迭代声明一个独立变量实例
```javascript
for (let i = 0; i < 4; ++i) {
    setTimeout(() => {
        console.log(i);
    }, 0)
}
```
#### const
const声明一个只读的常量。一旦声明，常量的值就不能改变。
只在声明所在的块级作用域内有效。声明的常量也是不提升，同样存在暂时性死区.与let一样不可重复声明
可以用const声明一个**不会被修改**的for循环变量，for-of 和 for-in
```javascript
let i = 0
for (const j = 1; i < 3; ++i) {
    console.log(i);
}
for (const key in { a: '1', b: '2' }) {
    console.log(key);
}
for (const iterator of['a', 'b', 'c']) {
    console.log(iterator);
}
```
const变量值不能改动，本质上是变量指向的那个内存地址所保存的数据不得改动，简单类型的数据就在这个内存地址里，而复合类型的数据（主要是对象和数组），变量指向的内存地址保存的只是一个指向实际数据的指针，不能限制实际数据的修改
#### 顶层对象的属性
声明变量的方法；ES5 var命令和function命令。ES6 let和const命令，import命令和class命令。
**顶层对象**，在浏览器环境指的是window对象，在Node指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
 ES6中，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
**globalThis** ES2020，引入globalThis，可以从它这里拿到顶层对象，指向全局环境下的this。


### 函数对象和NFE命名函数表达式
**函数对象**
- 函数就是对象,可被调用的"行为对象"。
- 函数对象包含一些便于使用的属性,属性不是变量,和变量不相关.
  - name —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。
  - length —— 函数定义时的入参的个数。Rest 参数不参与计数。
  - 自定义属性。很多知名的 JavaScript 库都充分利用了这个功能。它们创建一个“主”函数，然后给它附加很多其它“辅助”函数。例如，jQuery 库创建了一个名为 $ 的函数。lodash 库创建一个 _ 函数，然后为其添加了 _.add、_.keyBy 以及其它属性。实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。
```javascript
function makeCounter(){
    function counter(){
        return counter.count++
    }
    counter.count=0
    counter.set = function (value){
        counter.count = value
    }
    counter.decrease= function(){
        counter.count--
    }
    return counter

}

let counter = new makeCounter()
counter.set(5)
counter.decrease()
counter.decrease()
console.log(counter());
console.log(counter());
```

**NFE命名函数表达式**
如果函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）。这个名字可以用于在该函数内部进行自调用，例如递归调用等。
给函数表达式添加的可选的名字，正是用来解决函数表达式变量修改导致自身调用出错的问题
```javascript
//使用函数表达式自身调用出错的场景
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // Error: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;
welcome(); // Error，嵌套调用 sayHi 不再有效！

//使用命名函数表达式
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // 现在一切正常
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest（嵌套调用有效）
```

```javascript
// 任意数量任意参数的括号求和

function getSum(a,...args){
    let currentSum
      if(args){
           currentSum = a;
          for(let item of args){
            currentSum +=item
          }
      }else{
           currentSum = a;
      } 
      function f(b,...args){
        if(args){
          currentSum += b
          for(let item of args){
            currentSum +=item
          }
        }else{
          currentSum += b
        }
        
        return f
      }
      f.toString= function(){
          return currentSum
      }
      return f
}
//比较运算符会自动将右侧值对象转换进行比较，转化会使用到toString方法，由于方法被重写，不会调用对象原型的toSting方法，alert方法也会有类似的转换。
// alert(getSum(0)(1))
console.log(getSum(0)(1)==1);//getSum(0)(1)比较时相当于getSum(0)(1).toString();
console.log(getSum(1)(2,3)==6);//true
console.log(getSum(1,11)(2,3)(6)(4,5,7,8,9,10)==66)//true
```

### "new Function" 语法

- 创建函数的一种方法，通过使用参数列表和给定函数体作为参数创建的，在一些特定的场景会用到它，如从服务器获取代码或者动态地从模板编译函数时才会使用。
- 只能通过参数传值，不能直接使用外部变量。
- 如果使用new Function创建一个函数，那么该函数的[[Environment]]并不指向当前的词法环境，而是指向全局环境。
```javascript
function getFunc() {
  let value = "test";

  let func = new Function('alert(value)');

  return func;
}
let value = "outer";

getFunc()(); // outer 如果全局没有定义value，会抛出 error: value is not defined
```
### 调度：setTimeout 和 setInterval

- setTimeout(func, delay, ...args) 和 setInterval(func, delay, ...args) 方法允许我们在 delay 毫秒之后运行 func一次或以 delay 毫秒为时间间隔周期性运行 func。
- 要取消函数的执行clearInterval/clearTimeout，并将 setInterval/setTimeout 返回的值作为入参传入。
- 嵌套的 setTimeout 比 setInterval 用起来更加灵活，允许我们更精确地设置两次执行之间的时间,setInterval执行间隔包括函数执行的时间。
- 零延时调度`setTimeout(func, 0)`与`setTimeout(func)`相同用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。
- 浏览器会将 setTimeout或setInterval 的五层或更多层嵌套调用(调用五次之后)的最小延时限制在 4ms。这是历史遗留问题。
- 所有的调度方法都不能保证确切的延时.
```javascript
//使用 setInterval
// function printNumbers(from,to){
//     let index = from
//     let run = () => {
//         console.log(index);
//         index++
//         if(index>to){
//             clearInterval(timer)
//         }
//     }
//     run()
//     let timer = setInterval(run, 1000);
// }
// printNumbers(2,6)

// //使用嵌套的setTimeout。
function printNumbers(from,to){
    let index = from;
    let timer1 = setTimeout(function run(){
        let timer2 =null;
        console.log(index);
        if(index<to){
            timer2 = setTimeout(run,1000)
        }else{
            clearTimeout(timer2)
        }
        index++;
        
    })
    
}
printNumbers(2,6)
```

### 装饰器模式和转发，call/apply

- 装饰器是对函数行为修饰的一种包装器函数，给函数添枝加叶,主要工作仍由该函数来完成,可以有多个共同修饰。
- 通常被装饰器修饰过的函数它的原始函数属性是访问不了的。但是存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的Proxy对象来包装函数。
- 由于装饰器是包装器函数,免不了使用this,通过call/apply方法能让函数绑定合适的对象。
  - func.call(context, ...arg1) —— 用给定的上下文和参数调用 func。
  - func.apply(context, args) —— 调用 func 将 context 作为 this 和类数组的 args 传递给参数列表。
    * Spread 语法 ... 允许将 可迭代对象 args 作为列表传递给 call。
    * apply 仅接受 类数组对象 args。
    * 对于可迭代又是类数组的对象，例如数组，我们使用call、apply均可，但是apply可能会更快
  - **呼叫转移**：所有参数连同上下文一起传递给另一个函数被称为呼叫转移call forwarding。
  -  **方法借用** `method borrowing`从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。

```javascript
//呼叫转移
let wrapper = function() {
  return original.apply(this, arguments);
};
//方法借用
// 从常规数组 [].join 中获取（借用）join 方法，并使用 [].join.call 在 arguments 的上下文中运行它。
function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
```
**装饰器应用**
```javascript
/**
 * 
间谍装饰器
ps.该装饰器有时对于单元测试很有用。它的高级形式是 Sinon.JS 库中的 sinon.spy。

// 由 spy(f) 返回的包装器应存储所有参数，然后使用 f.apply 转发调用。
function getSum(a,b){
    console.log(a+b);
}

function spy(func){

    wrapper.calls = []
    function wrapper(...args){
        console.log(typeof args);
        wrapper.calls.push(args)
        func.apply(this,args)
    }
    return  wrapper
}
let sum = spy(getSum)
sum(2,7)
sum(4,7)
console.log(sum.calls);
*/

/**
* 延时装饰器

function log(x){
    console.log(x)
}
function delay(fun,delayTime){
    return function(){
        setTimeout(()=>{
            fun.apply(this,arguments)
        },delayTime)
    }
}
let delaylog = delay(log,1000)
delaylog(4)
delaylog(5)
delaylog(6)
*/

/** 
防抖装饰器

debounce 是一个处理一系列事件的好方法：无论是系列键盘输入，鼠标移动还是其他类似的事件。
它在最后一次调用之后等待给定的时间，然后运行其可以处理结果的函数。
search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。
function mockRequest(){
    console.log("发送请求");
}
function debounce(func,delay){
    let timer =null;
    return function (){
        clearTimeout(timer)
        timer = setTimeout(()=>{
            func.apply(this,arguments)
        },delay)
    }
}
let f = debounce(mockRequest,1000)
let count =0
// 延时器延迟时间小于1000ms,就会触发防抖效果,只请求一次
let timer1 = setInterval(() => {
    f()
    count++
    if(count>=6){
        clearInterval(timer1)
    }
}, 500);

*/

/** 
 节流装饰器
当被多次调用时，它会在每 ms 毫秒最多将调用传递给 f 一次。
鼠标指针移动时，更新网页上的某些信息。
鼠标不断点击触发，mousedown(单位时间内只触发一次)。
监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。
*/
function mockRequest(x){
    console.log("发送请求:"+x);
}
function throttle(func,delay){
    let timer = null;
    let isThrottle=false
    let saveThis,saveArgs;
    function wrapper(){
        if(isThrottle){
            saveThis = this
            saveArgs = arguments
            return
        }
        
        func.apply(this,arguments)// 1
        isThrottle=true

        setTimeout(()=>{
            isThrottle = false
            if(saveArgs){
                wrapper.apply(saveThis,saveArgs)
                saveThis=saveArgs=null;
            }           
        },delay)

    }
    return wrapper
}
let f = throttle(mockRequest,5000)
let i=1
let timer1 = setInterval(() => {
    f(i++)
    // console.log(i++);
    if(i>100){
        clearInterval(timer1)
    }
}, 100);
```

### 函数绑定

**this丢失**
- 一旦方法被传递到与对象分开的某个地方，this 就丢失。像下面定时器的例子
```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
// 浏览器中的 setTimeout 方法有些特殊：它为函数调用设定了 this=window（对于 Node.js，this 则会变为计时器（timer）对象，但在这儿并不重要,如果不指定this,它作为函数调用, this也会指向Window）。
```
**解决方法**
- 解决方式一,包装器,让它作为对象的方法被调用。
`setTimeout(() => user.sayHi(), 1000); // Hello, John!`
- 解决方式二,bind,函数提供了一个内建方法 bind，它可以绑定 this。
`setTimeout(user.sayHi.bind(user), 1000); // Hello, John!`
**偏函数（Partial functions）**
- 当我们绑定一个现有的函数的某些参数时，绑定后的（不太通用的）函数被称为偏函数 partially applied 或 partial。
- 其实就是使用bind接收参数的原理
```javascript
 function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10 
```
**this练习**
```javascript
/**

//作为方法的绑定函数
function f(){
    console.log(this.clearInterval);
}

let user = {
    name:"nangong",
    methods: f.bind(null)
}
user.methods()
*/

/**
// 二次bind
f.bind(...) 返回的外来（exotic）绑定函数 对象仅在创建的时候记忆上下文（以及参数，如果提供了的话）。
一个函数不能被重绑定（re-bound）。

function f(){
    console.log(this);
    console.log(this.name);
}
f = f.bind({name:"nangong"}).bind({name:"kyo"})
f() //nangong
*/

/** 
 bind 后的函数属性
bind后指向的是另一个对象。它并没有原来的函数属性。
function f(){
    console.log(this.name);
}
f.test = "test"
f = f.bind({name:'nangong'})
f();
//bind 的结果是对象{name:'nangong'}。它并没有 test属性。
console.log(f.test);
*/

/** 
 * 修复丢失了 "this" 的函数


function validatePassword(success,error){
    let passsword = prompt('输入密码,提示：jjy',"")
    if(passsword === "940618"){
        success()
    }else{
        error()
    }
}
let user = {
    name:"administrator",
    success(){
        console.log(this)
        console.log(this.name+"登录成功");
    },
    error(){
        console.log(this)
        console.log((this.name+"登录失败,密码错误"));
    }
}
// 强制改变this指向
// validatePassword(user.success.bind(user),user.error.bind({name:"nangong"}))

// 使用包装wapper函数，箭头函数更简洁,作为对象方法调用,this指向user 
validatePassword(() => user.success,() => user.error)

*/

/** 
 偏函数在登录中的应用
*/

function validatePassword(success,error){
    let passsword = prompt('输入密码,提示：jjy',"")
    if(passsword === "940618"){
        success()
    }else{
        error()
    }
}
let user = {
    name:"administrator",
    login(result){
        console.log(this)
        console.log(this.name+(result?"登录成功":"登录失败,密码错误"));
    }
}
// user.login 创建一个偏函数，该函数使用 user 作为上下文，并具有正确的第一个参数：
// validatePassword(user.login.bind(user,true),user.login.bind(user,false))

// 使用包装wapper函数，箭头函数更简洁,作为对象方法调用,this指向user 
validatePassword(() => user.login(true),() => user.login(false))
```

### 箭头函数深入理解
- 表现形式
    不带花括号：(...args) => expression — 右侧是一个表达式：函数计算表达式并返回其结果。
    带花括号：(...args) => { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。
- 没有this
  箭头函数没有this，如果在它里面访问this,它会从外部寻找this
    **箭头函数 VS bind**
    箭头函数 => 和使用 .bind(this) 调用的常规函数之间有细微的差别：
    .bind(this) 创建了一个该函数的“绑定版本”。
    箭头函数 => 没有创建任何绑定。箭头函数只是没有 this。this 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。
```javascript
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    // this.students.forEach(
    //   student => alert(this.title + ': ' + student)
    // );

    //不使用箭头函数，就需要给forEach里面的函数绑定this，如果不绑定就里面的函数运行时this默认指向undefined
    this.students.forEach(function(student) {
        return alert(this.title + ': ' + student)
    }.bind(this));
  }
};

group.showList();

```
- 没有arguments，可以通过剩余参数`...args`接收箭头函数参数
装饰器应用
```javascript
// 装饰器
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  };
}

// 包装器
function sayHi(who) {
  alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John"); // 2 秒后显示：Hello, John

```
- 不能使用new 关键字进行调用
    不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）

- 没有super


