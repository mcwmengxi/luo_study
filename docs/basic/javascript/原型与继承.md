---
title: 原型与继承
date: 2021-11-212
author: luo
img: https://statics.sh1a.qingstor.com/2018/10/08/1.jpg
categories: 前端
tags:
  - JavaScript
---
## 原型与继承

### 原型和原型链
JavaScript中几乎所有的对象都是位于原型链顶端的Object的实例。
每个对象都有一个私有属性`[[prototype]]`，它通常会被赋值为构造函数的原型对象(`prototype`对象)，这个`prototype`对象又具有自己的原型，层层向上直到对象的原型为null.
根据定义，null没有原型，常作为原型链的终点
```javascript
console.log(Object.getPrototypeOf(Object.prototype)===null)//true
```
#### 属性的查找
`javascript`对象有一条执行原型对象的链。
当要访问对象的属性时，它不仅会在该对象上搜索，还会在该对象的原型上搜索，以及该对象原型的原型，依次向上搜索，直到找到相匹配的属性或是到达原型链的终点。
检查对象属性是否为自己定义的属性，而不是其原型链上的某个属性，则必须使用对象从Object.prototype继承的hasOwnProperty方法。
```javascript
// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：
var o = {a: 1, b: 2};
// o 的原型 o.__proto__有属性 b 和 c：
o.__proto__ = {b: 3, c: 4};
// 最后, o.__proto__.__proto__ 是 null.
// 这就是原型链的末尾，即 null，
// 根据定义，null 没有__proto__.
// 综上，整个原型链如下:
{a:1, b:2} ---> {b:3, c:4} ---> null

console.log(o.a); // o.a => 1
console.log(o.b); // o.b => 2
console.log(o.c); // o.c => o.__proto__.c => 4
console.log(o.d); // o.c => o.__proto__.d => o.__proto__.__proto__ == null => undefined
```
#### 创建对象和生成原型链
1. 使用普通语法创建对象(注释为原型链).
```javascript
var o = { a: 1 }; // o ---> Object.prototype ---> null
var a = ["yo", "whadup", "?"]; // a ---> Array.prototype ---> Object.prototype ---> null
function f() {
  return 2;
} // f ---> Function.prototype ---> Object.prototype ---> null
```
2. 使用构造器.
当继承的函数被调用时，this指向的是当前继承的对象，而不是继承的函数所在的原型对象。
```javascript
        function DoublyLinkedList() {
            this.head = null
            this.tail = null
            this.items = []

            DoublyLinkedList.prototype.size = function(element) {
                return this.items.length
            }
        }
        var dLinkedList = new DoublyLinkedList()
        console.log(dLinkedList);
      // dLinkedList是生成的对象,他的自身属性有'items','head'和'tail'.
      // 在dLinkedList被实例化时,dLinkedList.__proto__指向了DoublyLinkedList.prototype.
```
3. 使用class关键字(ECMAScript6，只是语法糖，JavaScript仍然是基于原型的)
```javascript
        class DoublyLinkedList {
            constructor() {
                this.head = null
                this.tail = null
                this.items = []
            }
            size() {
                return this.items.length
            }
        }
        var dLinkedList = new DoublyLinkedList()
```
4. 使用Object.create


#### proto 与 prototype

prototype为显式原型：每个函数创建后都会有一个名为prototype的属性，这个属性指向函数的原型对象。
显式原型的作用：用来实现基于原型的继承与属性的共享。

__proto__为隐式原型，指向创建这个对象的构造函数(constructor)的原型(prototype)。
隐式原型的作用：构成原型链，同样用于实现基于原型的继承。

**原型链图解**：

![原型链](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg)